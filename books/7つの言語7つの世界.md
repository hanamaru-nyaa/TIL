# 7つの言語と7つの世界🌎

## 概要
7つの言語を少しずつ取り扱い、比較しながら特徴を学ぶことができる。

## 目的
様々なパラダイムのプログラミング言語を学ぶことで、固定概念にとらわれたプログラミングライフを送らないこと。プログラミング言語を抽象化する手助けとし、全体を見渡せるようになる。

## Ruby
### 簡単な歴史
Rubyはオブジェクト指向の言語として紹介されている。シンタックスシュガーによってプログラマの生産効率が向上し、楽しくプログラムが書けるように設計されている。インタープリタ型言語（型が実行時にバインドされる）で実行速度は比較的遅い。

### 1日目
#### Rubyに触れてみよう。

なにか戻り値を返すように指定しなくても、必ず値が返ってくる。

ex.代入でも値が返ってくる。
```
>> language = 'Ruby'
=> "Ruby"
```

#### Rubyは純粋なオブジェクト指向言語である。
あらゆるものがオブジェクトとして定義されている。

ex.数値
```
>> 4.class
=> Fixnum
```

また、ドット演算子を使ってオブジェクトのメソッドを呼び出せる
```
>> 4.methods
=> ["inspect", "%", ">>", ・・・]
```

#### 判定
true, falseといった評価も可能。
また、unless文を使用すると、falseである場合の条件ブロックの可読性を上げられる。
```
>> unless x==4
>> 	 puts 'xは4ではありません。'
>> else
>>	 puts 'xは4です。'
>> end
```

#### 型モデル
Rubyは型が衝突するとエラーになる。
```
>> 4 + 'four'
TypeError: String can't be coerced into Fixnum
```

また、型チェックは実行時に行われれる（動的型付け）。
実際に、関数の定義などでは型エラーが起きない。

##### 動的型付けであるメリット
クラスは同じように使うからといって、同じ親から継承する必要はない。

String型とFloat型はどちらでも.to_iメソッド（Int型に変換するメソッド）を使用できる。
基盤が何の型でもいいということ。

オブジェクト指向設計では、実装（具体）ではなく、インターフェース（抽象）に合わせるべきである。

**動的型付けは静的型付けよりも補足できるエラーが少なくなることは意識したい。**

### 2日目
#### 関数
- クラスの定義をしなくてもOK
- 戻り値を必ず返す。（ない場合は最後の式の値を返す。）

#### 配列
[ ]はArrayクラスのメソッドであることをおさえる。
これによって配列操作が簡単に行える。シンタックスシュガーなのである。（覚えた言葉を使いたがる）

#### ハッシュ
配列と動作はほとんど同じだが、整数インデックスの代わりに「任意の値」をキーにできる特徴がある。
```
>> numbers = {1 => 'one', 2 => 'two'}
```

#### コードブロック
コードブロックとは一言でいえば、名前のない関数である。
ex.3回繰り返し出力するコード
```
>> 3.times {puts 'hello '}
=> hello hello hello
```
{}がコードブロックである。
関数やメソッドに引数として渡すことができる。

複数行になると、do/endで囲んでコードブロックを表す。

#### クラス
Rubyは1つの親からのみ継承できる。複数はできない。
例えば以下のようになっている。

親｜Object > Numeric > Integer > Fixnum > 1

ちなみに、Ruby 1.9からObjectクラスの親としてBasicObjectクラスが登場したらしい・・・

initializeメソッドはインスタンス化の際に呼び出されるメソッドのことを指す。
（PHPでいうとconstructメソッドみたいな感じ）

attrについて
getterやsetterを簡単に定義できるもの
```
class User
	attr_reader :name #nameを読み取れる

	def initialize(name)
		@name = name
	end
end
```
- attr_writerはsetterの作成
- attr_accessorは読み書き両方を作成

*以下、Rubyの慣習*
クラスはアッパーキャメルケースを使う。

インスタンス変数は、オブジェクト（＝インスタンス）ごとに1つの値を持つ変数で「@」を先頭に付ける。
クラス変数は、クラスごとに1つの値を持つ変数で「@@」を先頭に付ける。

定数は大文字で書く。

インスタンス変数とメソッド名は小文字でスネークケースで書く。

判定用のメソッドには疑問符をつける
```
if test?
```

#### Mixin
前提として、複数のクラスから継承を行う「多重継承」は複雑で問題が多いことが知られている。
PHPやJavaではインターフェースでこの問題を解決している。
Rubyではクラスの一部としてモジュールをMixin(混ぜ込む)ことによってこの問題を解決している。

以下がモジュールの例である。
```
module ToFile
	def filename
		"object_#{self.object_id}.txt"
	end

	def to_f
		File.open(filename, 'w') {|f| f.write(to_s)}
	end
end

class Person
	include ToFile
	attr_accessor :name

	def initialize(name)
		@name = name
	end

	def to_s
		name
	end
end
```

to_sメソッドはモジュールで使用されているが、実装はクラスで行われている。
つまり、to_sメソッドがどのような実装になっているかto_fは知らない。
Personクラスでもほかのクラスでもto_sメソッド（文字列を出力するメソッド）があればそれをファイル出力するのがto_fメソッドなのだ。

Rubyではインターフェースは存在しないので、暗黙的に行う。

ダックタイピングという言葉も紹介されていた。
「もしそれがアヒルのように歩き、アヒルのように鳴くなら、それはアヒルである」というように、オブジェクトの「型（クラス）」ではなく、「持っているメソッドや振る舞い」で判断するということを表現している。つまり暗黙的ということ。

ちなみに自分はあまりこの考え方が好きではない。

また、モジュールはincludeすればおわりという簡単さも重要である。